<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gravador com Transcrição e Atividades</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
  <style>
    body {
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      color: #fff;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      min-height: 100vh;
      padding: 20px;
    }
    h2, h3 {
      font-weight: 700;
      text-align: center;
    }
    .card {
      max-width: 900px;
      margin: 0 auto;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      background: #fff;
      color: #333;
      border: none;
    }
    button {
      border-radius: 50px;
      font-weight: 600;
      padding: 10px 20px;
      transition: transform 0.2s ease;
    }
    button:hover { transform: scale(1.05); }
    #timer {
      font-weight: bold;
      font-size: 1.2rem;
      margin-left: 15px;
      color: #1e3c72;
    }
    #visualizer {
      width: 100%;
      height: 100px;
      background: #f1f1f1;
      border-radius: 12px;
    }
    textarea {
      border-radius: 12px;
      resize: none;
      box-shadow: inset 0 3px 8px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>

  <div class="container-fluid">
    <h2 class="mb-4">Gravador e Assistente de Conteúdo</h2>

    <div class="card">
      <div class="card-body d-flex flex-column">

        <div class="d-flex flex-wrap justify-content-center align-items-center mb-4 gap-2">
          <button id="recordBtn" class="btn btn-success">Gravar</button>
          <button id="stopBtn" class="btn btn-danger" disabled>Parar</button>
          <button id="transcribeBtn" class="btn btn-primary">Transcrever</button>
          <button type="button" class="btn btn-info" data-bs-toggle="modal" data-bs-target="#activityModal">
            Gerar Atividade
          </button>
          <span id="timer">00:00</span>
        </div>

        <canvas id="visualizer" class="mb-3"></canvas>

        <div class="mb-4">
          <label for="audioFile" class="form-label fw-bold">Ou envie um arquivo de áudio:</label>
          <input type="file" id="audioFile" class="form-control" accept="audio/*">
        </div>

        <div class="row flex-grow-1">
          <div class="col-12 col-md-6 mb-3 d-flex flex-column">
            <label class="form-label">Transcrição:</label>
            <textarea id="transcription" class="form-control flex-grow-1" rows="8" readonly></textarea>
          </div>
          <div class="col-12 col-md-6 mb-3 d-flex flex-column">
            <label class="form-label">Resumo em Tópicos:</label>
            <textarea id="summary" class="form-control flex-grow-1" rows="8" readonly></textarea>
          </div>
        </div>

        <div class="d-flex justify-content-center gap-2 mt-auto pt-3">
          <button id="downloadTranscriptionBtn" class="btn btn-outline-secondary">Baixar Transcrição</button>
          <button id="downloadSummaryBtn" class="btn btn-outline-secondary">Baixar Resumo</button>
        </div>

      </div>
    </div>
  </div>

  <div class="modal fade" id="activityModal" tabindex="-1" aria-labelledby="activityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="activityModalLabel">Gerador de Atividades</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          
          <div class="mb-3">
            <label for="activityType" class="form-label fw-bold">1. Escolha o tipo de atividade:</label>
            <select id="activityType" class="form-select">
              <option value="dissertativa">Questões Dissertativas</option>
              <option value="objetiva">Questões Objetivas</option>
            </select>
          </div>

          <div id="objectiveOptions" class="d-none border p-3 rounded bg-light">
            <p class="fw-bold">2. Configure as questões objetivas:</p>
            <div class="mb-3"><label for="difficulty" class="form-label">Dificuldade:</label><select id="difficulty" class="form-select"><option value="iniciante">Iniciante</option><option value="intermediario">Intermediário</option><option value="avancado">Avançado</option></select></div>
            <div class="mb-3"><label for="quantity" class="form-label">Quantidade:</label><select id="quantity" class="form-select"><option value="5">Até 5 questões</option><option value="10">Até 10 questões</option><option value="20">Até 20 questões</option></select></div>
            <div class="mb-3"><label for="questionType" class="form-label">Formato:</label><select id="questionType" class="form-select"><option value="multipla escolha">Múltipla Escolha</option><option value="associar colunas">Associar Colunas</option><option value="verdadeiro ou falso">Verdadeiro ou Falso</option><option value="assinale a excecao">Assinale a Exceção</option><option value="completar as lacunas">Completar Lacunas</option></select></div>
          </div>

        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
          <button id="generateActivityBtn" class="btn btn-info">Gerar Atividade em PDF</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  
  <script>
    const { jsPDF } = window.jspdf;

    // --- Seletores de Elementos ---
    const recordBtn = document.getElementById("recordBtn");
    const stopBtn = document.getElementById("stopBtn");
    const transcribeBtn = document.getElementById("transcribeBtn");
    const downloadTranscriptionBtn = document.getElementById("downloadTranscriptionBtn");
    const downloadSummaryBtn = document.getElementById("downloadSummaryBtn");
    const timerElement = document.getElementById("timer");
    const audioFileInput = document.getElementById("audioFile");
    const transcriptionArea = document.getElementById("transcription");
    const summaryArea = document.getElementById("summary");
    const visualizer = document.getElementById("visualizer");
    const activityType = document.getElementById('activityType');
    const objectiveOptions = document.getElementById('objectiveOptions');
    const generateActivityBtn = document.getElementById('generateActivityBtn');
    
    // Instância do Modal para podermos controlá-lo via JS
    const activityModalEl = document.getElementById('activityModal');
    const activityModal = new bootstrap.Modal(activityModalEl);

    // --- Variáveis de Estado ---
    let mediaRecorder, recordedChunks = [], recordedBlob;
    let audioContext, analyser, source, dataArray;
    let isRecording = false, isPaused = false;
    let timerInterval, seconds = 0;

    // --- Funções de Gravação, Timer, Visualizador, Transcrição, etc. (permanecem iguais) ---
    function startTimer() {
        timerInterval = setInterval(() => {
            seconds++;
            const min = String(Math.floor(seconds / 60)).padStart(2, "0");
            const sec = String(seconds % 60).padStart(2, "0");
            timerElement.textContent = `${min}:${sec}`;
        }, 1000);
    }
    function stopTimer() { clearInterval(timerInterval); }
    function resetTimer() { clearInterval(timerInterval); seconds = 0; timerElement.textContent = "00:00"; }
    function drawVisualizer() {
        const ctx = visualizer.getContext("2d");
        const draw = () => {
            requestAnimationFrame(draw);
            if (!analyser) return;
            analyser.getByteTimeDomainData(dataArray);
            ctx.fillStyle = "#f1f1f1";
            ctx.fillRect(0, 0, visualizer.width, visualizer.height);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#1e3c72";
            ctx.beginPath();
            const sliceWidth = visualizer.width * 1.0 / analyser.fftSize;
            let x = 0;
            for (let i = 0; i < analyser.fftSize; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * visualizer.height / 2;
                if (i === 0) { ctx.moveTo(x, y); } else { ctx.lineTo(x, y); }
                x += sliceWidth;
            }
            ctx.lineTo(visualizer.width, visualizer.height / 2);
            ctx.stroke();
        };
        draw();
    }
    recordBtn.addEventListener("click", async () => {
        if (!isRecording) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 2048;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                drawVisualizer();
                mediaRecorder = new MediaRecorder(stream);
                recordedChunks = [];
                mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = async () => {
    // 1. Informa ao usuário que a conversão está acontecendo
    transcriptionArea.value = "Finalizando gravação e convertendo para MP3...";
    summaryArea.value = "";

    try {
        // 2. Cria o Blob original no formato WebM
        const webmBlob = new Blob(recordedChunks, { type: "audio/webm" });

        // 3. Converte o Blob para um formato que a API de áudio entende
        const arrayBuffer = await webmBlob.arrayBuffer();
        
        // Garante que o audioContext está ativo para decodificar
        if (!audioContext || audioContext.state === 'closed') {
             audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        // 4. Inicia o codificador MP3 da biblioteca lamejs
        // Parâmetros: (Nº de canais, Taxa de amostragem, Bitrate em kbps)
        const mp3Encoder = new lamejs.Mp3Encoder(1, audioBuffer.sampleRate, 128);
        
        // Pega os dados de áudio puros (PCM)
        const pcmData = audioBuffer.getChannelData(0);
        // O LAME precisa dos dados em um formato específico (Int16)
        const samples = new Int16Array(pcmData.length);
        for (let i = 0; i < pcmData.length; i++) {
            // Converte o formato de ponto flutuante para inteiro de 16 bits
            samples[i] = pcmData[i] * 32767;
        }

        const mp3Chunks = [];
        const chunkSize = 1152; // Tamanho de bloco padrão para o LAME
        for (let i = 0; i < samples.length; i += chunkSize) {
            const chunk = samples.subarray(i, i + chunkSize);
            const mp3Chunk = mp3Encoder.encodeBuffer(chunk);
            if (mp3Chunk.length > 0) {
                mp3Chunks.push(mp3Chunk);
            }
        }

        // 5. Finaliza o processo de codificação
        const finalMp3Chunk = mp3Encoder.flush();
        if (finalMp3Chunk.length > 0) {
            mp3Chunks.push(finalMp3Chunk);
        }

        // 6. Cria o Blob final no formato MP3
        const mp3Blob = new Blob(mp3Chunks, { type: 'audio/mpeg' });
        
        // 7. Define o resultado na variável global que o botão "Transcrever" usa
        recordedBlob = mp3Blob;
        
        console.log("Conversão para MP3 concluída. Tamanho do arquivo:", mp3Blob.size);
        transcriptionArea.value = "Áudio convertido para MP3. Pronto para transcrever!";

    } catch (error) {
        console.error("Erro ao converter áudio para MP3:", error);
        transcriptionArea.value = "Falha ao converter o áudio. Tente gravar novamente.";
        // Como fallback, podemos tentar usar o webm original
        recordedBlob = new Blob(recordedChunks, { type: "audio/webm" });
    } finally {
        if(audioContext && audioContext.state !== 'closed') audioContext.close();
    }
};
                mediaRecorder.start();
                startTimer();
                isRecording = true;
                recordBtn.textContent = "Pausar";
                recordBtn.classList.replace("btn-success", "btn-warning");
                stopBtn.disabled = false;
            } catch (err) {
                alert("Não foi possível iniciar a gravação. Verifique as permissões do microfone.");
            }
        } else if (!isPaused) {
            mediaRecorder.pause(); stopTimer(); isPaused = true;
            recordBtn.textContent = "Retomar"; recordBtn.classList.replace("btn-warning", "btn-primary");
        } else {
            mediaRecorder.resume(); startTimer(); isPaused = false;
            recordBtn.textContent = "Pausar"; recordBtn.classList.replace("btn-primary", "btn-warning");
        }
    });
    stopBtn.addEventListener("click", () => {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop(); stopTimer(); isRecording = false; isPaused = false;
            recordBtn.textContent = "Gravar"; recordBtn.className = "btn btn-success";
            stopBtn.disabled = true; resetTimer();
        }
    });
    audioFileInput.addEventListener("change", (e) => {
        if (e.target.files[0]) { recordedBlob = e.target.files[0]; }
    });
    transcribeBtn.addEventListener("click", () => {
        if (!recordedBlob) return alert("Grave ou envie um arquivo de áudio primeiro!");
        sendAudioForTranscription(recordedBlob);
    });
    async function sendAudioForTranscription(file) {
        const formData = new FormData();
        formData.append("audio", file);
        transcriptionArea.value = "Enviando áudio..."; summaryArea.value = "";
        try {
            const API_URL = "https://voz-transcricao.onrender.com/transcribe-chunked";
            const response = await fetch(API_URL, { method: "POST", body: formData });
            if (!response.ok) throw new Error(`Falha: ${response.statusText}`);
            const { jobId } = await response.json();
            transcriptionArea.value = `Processando (ID: ${jobId})...`;
            pollJobStatus(jobId);
        } catch (err) {
            transcriptionArea.value = `Erro ao enviar: ${err.message}`;
        }
    }
    function pollJobStatus(jobId) {
        const intervalId = setInterval(async () => {
            try {
                const statusResponse = await fetch(`https://voz-transcricao.onrender.com/status/${jobId}`);
                if (!statusResponse.ok) { clearInterval(intervalId); transcriptionArea.value = "Trabalho não encontrado."; return; }
                const job = await statusResponse.json();
                if (job.status === "processing") transcriptionArea.value = `Progresso... ${job.progress.toFixed(0)}%`;
                else if (job.status === "summarizing") transcriptionArea.value = `Gerando resumo...`;
                else if (job.status === "completed") {
                    clearInterval(intervalId);
                    transcriptionArea.value = job.transcription;
                    summaryArea.value = job.summary || "";
                } else if (job.status === "failed") {
                    clearInterval(intervalId);
                    transcriptionArea.value = `Erro: ${job.error || 'Falha desconhecida'}`;
                }
            } catch (err) {
                clearInterval(intervalId);
                transcriptionArea.value = "Erro de comunicação.";
            }
        }, 5000);
    }

    // --- Lógica do Gerador de Atividades (AGORA DENTRO DO MODAL) ---
    activityType.addEventListener('change', () => {
        objectiveOptions.classList.toggle('d-none', activityType.value !== 'objetiva');
    });
    generateActivityBtn.addEventListener("click", async () => {
        const summaryText = summaryArea.value;
        if (!summaryText.trim()) return alert("É preciso ter um resumo para criar uma atividade!");
        const options = {
            type: activityType.value,
            difficulty: document.getElementById('difficulty').value,
            quantity: document.getElementById('quantity').value,
            questionType: document.getElementById('questionType').value
        };
        generateActivityBtn.disabled = true;
        generateActivityBtn.textContent = 'Gerando...';
        try {
            const response = await fetch("https://voz-transcricao.onrender.com/generate-activity", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ summaryText, options }),
            });
            if (!response.ok) throw new Error('Falha no servidor.');
            const { activityText } = await response.json();
            generatePdf("Atividade Gerada", activityText);
            activityModal.hide(); // Fecha o modal após o sucesso
        } catch (error) {
            alert("Ocorreu um erro ao gerar a atividade.");
        } finally {
            generateActivityBtn.disabled = false;
            generateActivityBtn.textContent = 'Gerar Atividade em PDF';
        }
    });

    // --- Funções de Download (PDF) ---
    function generatePdf(title, text) {
        if (!text.trim()) return alert(`Não há conteúdo para baixar!`);
        const doc = new jsPDF();
        doc.setFontSize(16); doc.text(title, 105, 15, null, null, 'center');
        doc.setFontSize(11);
        const splitText = doc.splitTextToSize(text, 180);
        doc.text(splitText, 15, 25);
        doc.save(`${title.replace(/\s+/g, '_').toLowerCase()}.pdf`);
    }
    downloadTranscriptionBtn.addEventListener("click", () => generatePdf("Transcricao", transcriptionArea.value));
    downloadSummaryBtn.addEventListener("click", () => generatePdf("Resumo", summaryArea.value));
  </script>
</body>
</html>
